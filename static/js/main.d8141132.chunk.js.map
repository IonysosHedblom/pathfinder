{"version":3,"sources":["algorithms/recursiveDivison.js","components/Node.jsx","components/Menu.jsx","components/Info.jsx","components/Tutorial.jsx","algorithms/dijkstra.js","algorithms/astar.js","algorithms/depthfirstsearch.js","algorithms/randomMaze.js","components/Board.jsx","App.js","index.js"],"names":["walls","Node","props","row","column","status","onMouseDown","onMouseEnter","onMouseUp","typeOfNode","shortestClass","shortest","className","id","Menu","algorithm","setAlgorithm","disable","startVisualize","setDisable","algorithmSpeed","setAlgorithmSpeed","setSpeedValue","speedValue","clearWalls","resetAll","recursiveDivisionMaze","buildRandomMaze","buildRandomWeightMaze","showTutorial","setShowTutorial","useState","showAlgos","setShowAlgos","showMazes","setShowMazes","showSpeedMenu","setShowSpeedMenu","algoDropdown","useRef","mazeDropdown","speedDropdown","closeDropdowns","useCallback","e","current","contains","target","useEffect","document","addEventListener","removeEventListener","changeAlgorithm","innerText","setSpeed","ref","onClick","Info","Tutorial","currentPage","setCurrentPage","page","disabled","href","rel","sortNodesByDistance","nodes","sort","node","nodeTwo","distance","getAllNodes","grid","push","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","getNeighbours","neighbours","neighbour","neighbourNotInUnvisitedNodes","unvisitedNodes","calculatedManhattanDistance","Math","abs","getUnvisitedNeighbours","range","len","result","i","getWalls","vertical","horizontal","start","direction","number","generateOddNum","addWall","slice","indexOf","isStartFinish","temporaryWalls","temporary","splice","generateEvenNum","wall","array","maxNum","randomNum","floor","random","max","randomMaze","forEach","Board","height","documentElement","clientHeight","width","clientWidth","calculatedRows","calculatedColumns","initialStartRow","initialStartColumn","initialTargetRow","initialTargetColumn","createNode","Infinity","totalDistance","createInitialGrid","currentRow","setGrid","isStartNodePressed","setIsStartNodePressed","isTargetNodePressed","setIsTargetNodePressed","pressedNode","setPressedNode","prevCoordinates","setPrevCoordinates","currentStartCoordinates","setCurrentStartCoordinates","currentTargetCoordinates","setCurrentTargetCoordinates","prevTargetCoordinates","setPrevTargetCoordinates","nodeTwoStepsBack","setNodeTwoStepsBack","targetTwoStepsBack","setTargetTwoStepsBack","isOnWallNode","setIsOnWallNode","setIsOnWeightNode","algoDone","setAlgoDone","weightKeyPressed","targetKey","keyPressed","setKeyPressed","downHandler","key","upHandler","window","useKeyPress","buildWalls","getElementById","classList","add","remove","handleMouseEnter","newGrid","currentNode","twoStepsBack","removePattern","resetGrid","newNode","newPreviousNode","moveStartNode","moveTargetNode","handleMouseUp","nodeById","updateWalls","visualizeDijkstras","visitedNodesInOrder","closestNode","shift","dijkstra","nodesInShortestPath","unshift","getNodesInShortestPath","animateAlgorithm","visualizeAstar","a","b","astar","nodesInShortestPathAstar","visualizeDfs","unvisitedNeighbours","unvisitedNeighbour","depthFirstSearch","nodesInShortestPathDfs","setTimeout","animateShortestPath","animateMaze","getGridWithMaze","animateWeightMaze","weights","weight","getGridWithWeightMaze","recursiveDivision","styles","map","rowIdx","nodeIdx","getStartNode","getTargetNode","handleMouseDown","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d8141132.chunk.js","sourcesContent":["let walls;\n\nexport const recursiveDivision = (grid, start, target) => {\n  walls = [];\n  if (!start || !target) {\n    return;\n  }\n\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n\n  getWalls(vertical, horizontal, grid, start, target);\n  return walls;\n};\n\nconst range = len => {\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst getWalls = (vertical, horizontal, grid, start, target) => {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let direction;\n  let number;\n  if (vertical.length > horizontal.length) {\n    direction = 0;\n    number = generateOddNum(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    direction = 1;\n    number = generateOddNum(horizontal);\n  }\n  if (direction === 0) {\n    addWall(direction, number, vertical, horizontal, start, target);\n    getWalls(\n      vertical.slice(0, vertical.indexOf(number)),\n      horizontal,\n      grid,\n      start,\n      target\n    );\n    getWalls(\n      vertical.slice(vertical.indexOf(number) + 1),\n      horizontal,\n      grid,\n      start,\n      target\n    );\n  } else {\n    addWall(direction, number, vertical, horizontal, start, target);\n    getWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(number)),\n      grid,\n      start,\n      target\n    );\n    getWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(number) + 1),\n      grid,\n      start,\n      target\n    );\n  }\n};\n\nconst addWall = (direction, number, vertical, horizontal, start, target) => {\n  let isStartFinish = false;\n  const temporaryWalls = [];\n  if (direction === 0) {\n    if (horizontal.length === 2) return;\n    for (let temporary of horizontal) {\n      if (\n        (temporary === start.row && number === start.column) ||\n        (temporary === target.row && number === target.column)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      temporaryWalls.push([temporary, number]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temporary of vertical) {\n      if (\n        (number === start.row && temporary === start.column) ||\n        (number === target.row && temporary === target.column)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      temporaryWalls.push([number, temporary]);\n    }\n  }\n  if (!isStartFinish) {\n    temporaryWalls.splice(generateEvenNum(temporaryWalls.length), 1);\n  }\n  for (let wall of temporaryWalls) {\n    walls.push(wall);\n  }\n};\n\nconst generateOddNum = array => {\n  const maxNum = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (maxNum / 2)) +\n    Math.floor(Math.random() * (maxNum / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === maxNum) {\n      randomNum--;\n    } else {\n      randomNum++;\n    }\n  }\n  return array[randomNum];\n};\n\nconst generateEvenNum = max => {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum--;\n    } else {\n      randomNum++;\n    }\n  }\n  return randomNum;\n};\n","import React from 'react';\n\nimport styles from '../assets/styles/Node.css';\n\nconst Node = props => {\n  const {\n    row,\n    column,\n    status,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    shortest,\n  } = props;\n\n  const typeOfNode =\n    status === 'start'\n      ? 'start'\n      : status === 'target'\n      ? 'target'\n      : status === 'wall'\n      ? 'wall'\n      : '';\n\n  const shortestClass = shortest ? 'node-shortest-path' : '';\n\n  return (\n    <td\n      onMouseDown={() => onMouseDown(row, column)}\n      onMouseEnter={() => onMouseEnter(row, column)}\n      onMouseUp={() => onMouseUp(row, column)}\n      className={`node ${typeOfNode} ${shortestClass}`}\n      id={`${row}-${column}`}\n    ></td>\n  );\n};\n\nexport default Node;\n","import React, { useState, useRef, useEffect, useCallback } from 'react';\n\nimport '../assets/styles/Menu.css';\n\nconst Menu = ({\n  algorithm,\n  setAlgorithm,\n  disable,\n  setDisable,\n  startVisualize,\n  algorithmSpeed,\n  setAlgorithmSpeed,\n  speedValue,\n  setSpeedValue,\n  clearWalls,\n  resetAll,\n  recursiveDivisionMaze,\n  buildRandomMaze,\n  buildRandomWeightMaze,\n  showTutorial,\n  setShowTutorial,\n}) => {\n  const [showAlgos, setShowAlgos] = useState(false);\n  const [showMazes, setShowMazes] = useState(false);\n  const [showSpeedMenu, setShowSpeedMenu] = useState(false);\n  const algoDropdown = useRef(null);\n  const mazeDropdown = useRef(null);\n  const speedDropdown = useRef(null);\n\n  const toggleAlgoDropdown = () => {\n    setShowAlgos(!showAlgos);\n    setShowMazes(false);\n    setShowSpeedMenu(false);\n  };\n\n  const toggleMazeDropdown = () => {\n    setShowMazes(!showMazes);\n    setShowAlgos(false);\n    setShowSpeedMenu(false);\n  };\n\n  const toggleSpeedDropdown = () => {\n    setShowSpeedMenu(!showSpeedMenu);\n    setShowMazes(false);\n    setShowAlgos(false);\n  };\n  const toggleTutorial = e => {\n    setShowTutorial(!showTutorial);\n  };\n  const closeDropdowns = useCallback(\n    e => {\n      if (!algoDropdown.current.contains(e.target)) {\n        setShowAlgos(false);\n      }\n      if (!mazeDropdown.current.contains(e.target)) {\n        setShowMazes(false);\n      }\n      if (!speedDropdown.current.contains(e.target)) {\n        setShowSpeedMenu(false);\n      }\n    },\n    [algoDropdown.current, mazeDropdown.current, speedDropdown.current]\n  );\n\n  useEffect(() => {\n    document.addEventListener('click', closeDropdowns);\n\n    return () => {\n      document.removeEventListener('click', closeDropdowns);\n    };\n  }, []);\n\n  const changeAlgorithm = e => {\n    if (e.target.innerText === \"Dijkstra's Algorithm\") {\n      setAlgorithm('dijkstra');\n    } else if (e.target.innerText === 'A* Search') {\n      setAlgorithm('astar');\n    } else if (e.target.innerText === 'Depth-first Search') {\n      setAlgorithm('dfs');\n    }\n  };\n\n  const setSpeed = e => {\n    if (e.target.innerText === 'Normal') {\n      setAlgorithmSpeed('Normal');\n      setSpeedValue(25);\n    } else if (e.target.innerText === 'Fast (default)') {\n      setAlgorithmSpeed('Fast');\n      setSpeedValue(10);\n    } else if (e.target.innerText === 'Slow') {\n      setAlgorithmSpeed('Slow');\n      setSpeedValue(100);\n    } else if (e.target.innerText === 'Ultra Slow') {\n      setAlgorithmSpeed('Ultra Slow');\n      setSpeedValue(500);\n    }\n  };\n\n  return (\n    <div className='menu'>\n      <h1>The Pathfinder</h1>\n      <nav>\n        <ul className='menu-list'>\n          <li ref={algoDropdown} onClick={() => toggleAlgoDropdown()}>\n            Algorithms\n            <span className='dropdown-arrow'></span>\n            <ul className={showAlgos === true ? 'algo-dropdown' : 'hidden'}>\n              <li onClick={e => changeAlgorithm(e)}>Dijkstra's Algorithm</li>\n              <li onClick={e => changeAlgorithm(e)}>A* Search</li>\n              <li onClick={e => changeAlgorithm(e)}>Depth-first Search</li>\n            </ul>\n          </li>\n\n          <li ref={mazeDropdown} onClick={() => toggleMazeDropdown()}>\n            Build Maze<span className='dropdown-arrow'></span>\n            <ul className={showMazes === true ? 'maze-dropdown' : 'hidden'}>\n              <li onClick={() => recursiveDivisionMaze()}>\n                Recursive Division\n              </li>\n              <li onClick={() => buildRandomMaze()}>Random maze pattern</li>\n              <li onClick={() => buildRandomWeightMaze()}>\n                Random Weight Maze\n              </li>\n            </ul>\n          </li>\n          <li ref={speedDropdown} onClick={() => toggleSpeedDropdown()}>\n            Speed: {algorithmSpeed}\n            <span className='dropdown-arrow'></span>\n            <ul\n              className={showSpeedMenu === true ? 'speed-dropdown' : 'hidden'}\n            >\n              <li onClick={e => setSpeed(e)}>Ultra Slow</li>\n\n              <li onClick={e => setSpeed(e)}>Slow</li>\n              <li onClick={e => setSpeed(e)}>Normal</li>\n              <li onClick={e => setSpeed(e)}>Fast (default)</li>\n            </ul>\n          </li>\n          <li>\n            <button\n              onClick={() => startVisualize()}\n              className={disable ? 'disabled' : ''}\n            >\n              Start{' '}\n              {algorithm === 'dijkstra'\n                ? \"Dijkstra's\"\n                : algorithm === 'astar'\n                ? 'A*'\n                : algorithm === 'dfs'\n                ? 'DFS'\n                : ''}\n            </button>\n          </li>\n          <li onClick={() => clearWalls()}>Clear walls</li>\n          <li onClick={() => resetAll()}>Reset board</li>\n\n          <li onClick={e => toggleTutorial(e)}>Tutorial</li>\n        </ul>\n      </nav>\n    </div>\n  );\n};\n\nexport default Menu;\n","import React from 'react';\nimport '../assets/styles/Info.css';\n\nconst Info = ({ algorithm, setAlgorithm }) => {\n  return (\n    <div className='info'>\n      <ul>\n        <li>\n          <div className='info-start'></div>Start Node\n        </li>\n        <li>\n          <div className='info-target'></div>Target Node\n        </li>\n        <li>\n          <div className='info-weight'></div>Weight Node\n        </li>\n        <li>\n          <div className='info-unvisited'></div>Unvisited Node\n        </li>\n        <li>\n          <div className='info-visited'></div>\n          <div className='info-visited2'></div>Visited Nodes\n        </li>\n\n        <li>\n          <div className='info-wall'></div>Wall Node\n        </li>\n        <li>\n          <div className='info-shortest'></div>Shortest-path Node\n        </li>\n      </ul>\n    </div>\n  );\n};\n\nexport default Info;\n","import React, { useState } from 'react';\n\nimport '../assets/styles/Tutorial.css';\n\nconst Tutorial = ({ showTutorial, setShowTutorial }) => {\n  const closeTutorial = e => {\n    setShowTutorial(false);\n  };\n  const [currentPage, setCurrentPage] = useState(1);\n\n  const handlePreviousClick = e => {\n    if (currentPage === 1) {\n      setCurrentPage(8);\n    } else {\n      setCurrentPage(currentPage - 1);\n    }\n  };\n\n  const handleNextClick = e => {\n    if (currentPage === 8) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(currentPage + 1);\n    }\n  };\n  const page =\n    currentPage === 1 ? (\n      <div className='tutorial-page'>\n        <h3>\n          Welcome to The Pathfinder App!\n          <hr />\n        </h3>\n\n        <h6>\n          Press{' '}\n          <span className='next-span'>\n            <button disabled>Next</button>\n          </span>{' '}\n          to see how it works.\n        </h6>\n        {/* <p className='purpose-paragraph'>\n          The purpose of The Trailblazer is to visualize pathfinding algorithms.\n        </p>\n        <p className='skip-paragraph'>\n          Press the <strong>\"Skip Tutorial\"</strong> button below if you want to\n          dive right in.\n          <br /> To learn more, press <strong>\"Next\"</strong>.\n        </p> */}\n\n        <div className='rocket-img'></div>\n      </div>\n    ) : currentPage === 2 ? (\n      <div className='tutorial-page'>\n        <h3>\n          Choose an algorithm\n          <hr className='hr-page-two' />\n        </h3>\n        <h6 className='page-three-h6'>\n          Choose an algorithm from the \"Algorithms\" drop-down menu at the\n          top-left of your screen.\n        </h6>\n\n        <div className='algo-img'></div>\n      </div>\n    ) : currentPage === 3 ? (\n      <div className='tutorial-page-four'>\n        <h3>\n          Meet the available algorithms\n          <hr />\n        </h3>\n\n        <ul>\n          <li>\n            <span>Dijkstra's Algorithm</span> (weighted): the father of\n            pathfinding algorithms; guarantees the shortest path\n          </li>\n          <li>\n            <span>A* Search</span> (weighted): arguably the best pathfinding\n            algorithm; uses heuristics to guarantee the shortest path much\n            faster than Dijkstra's algorithm\n          </li>\n          <li>\n            <span>Depth-first Search</span> (unweighted): a very bad algorithm\n            for pathfinding; does not guarantee the shortest path. I chose to\n            include this algorithm so that the user can see the differences\n            between a good pathfinding algorithm and a bad one.\n          </li>\n        </ul>\n      </div>\n    ) : currentPage === 4 ? (\n      <div className='tutorial-page'>\n        <h3>\n          Dragging nodes\n          <hr />\n        </h3>\n        <h6>Click and drag the start and target nodes to move them.</h6>\n\n        <div className='move-gif'></div>\n      </div>\n    ) : currentPage === 5 ? (\n      <div className='tutorial-page-five'>\n        <h3>\n          Adding walls\n          <hr />\n        </h3>\n        <h6>\n          <span>Walls: </span>Click and drag - Can not pass through.\n        </h6>\n        <h6>\n          <span>Weights: </span>Click and drag while holding \"W\"-key - Can pass\n          through.\n        </h6>\n\n        <div className='walls-gif'></div>\n      </div>\n    ) : currentPage === 6 ? (\n      <div className='tutorial-page'>\n        <h3>\n          Visualize and more!\n          <hr />\n        </h3>\n        <h6 className='page-seven-h6'>\n          Use the navbar buttons to visualize algorithms, change the speed of\n          the visualizer or let the app build a maze for you.\n        </h6>\n\n        <div className='navbar-img'></div>\n      </div>\n    ) : currentPage === 7 ? (\n      <div className='tutorial-page'>\n        <h3>\n          What is the purpose of The Pathfinder?\n          <hr />\n        </h3>\n        <h6 className='page-two-h6'>\n          Essentially, The Pathfinder is a pathfinding algorithm visualizer.\n        </h6>\n        <div className='page-two-paragraphs'>\n          <p className='page-two-explanation'>\n            A pathfinding algorithm seeks out the shortest path between a given\n            starting point and ending point. This application visualizes a\n            selection of pathfinding algorithms in action, and more.\n          </p>\n          <p className='page-two-explanation'>\n            The algorithms available in The Pathfinder are adapted for a 2D\n            grid, where 90 degree turns have a \"cost\" of 1 and movements from a\n            node to another also have a \"cost\" of 1. In this application,\n            weights have a \"cost\" of 10.\n          </p>\n        </div>\n\n        <div className='path-img'></div>\n      </div>\n    ) : currentPage === 8 ? (\n      <div className='tutorial-page-eight'>\n        <h3>\n          Hope you enjoy my application!\n          <hr />\n        </h3>\n        <h6>\n          If you are interested in the source code for this application, visit\n          my{' '}\n          <a\n            className='github-link'\n            href='https://github.com/IonysosHedblom'\n            target='_blank'\n            rel='noreferrer'\n          >\n            Github\n          </a>\n        </h6>\n      </div>\n    ) : (\n      ''\n    );\n\n  return (\n    <>\n      {showTutorial ? (\n        <div className='tutorial-container'>\n          {page}\n          <div className='tutorial-button-group'>\n            <button\n              onClick={e => closeTutorial(e)}\n              className='tutorial-button skip'\n            >\n              Skip Tutorial\n            </button>\n            <button\n              onClick={e => handlePreviousClick(e)}\n              className='tutorial-button previous'\n            >\n              Previous\n            </button>\n            <button\n              onClick={e => handleNextClick(e)}\n              className='tutorial-button next'\n            >\n              Next\n            </button>\n          </div>\n        </div>\n      ) : (\n        ''\n      )}\n    </>\n  );\n};\n\nexport default Tutorial;\n","// Performs Dijkstras algorithm, returns all nodes in the order which they were visited.\nexport const dijkstra = (grid, start, target) => {\n  const visitedNodesInOrder = [];\n  start.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n\n    // If wall is encountered. Skip it.\n    if (closestNode.status === 'wall') continue;\n\n    // If the closest node is at a distance of infinity, we are trapped.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === target) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n};\n\nconst sortNodesByDistance = nodes => {\n  nodes.sort((node, nodeTwo) => node.distance - nodeTwo.distance);\n};\n\nconst getAllNodes = grid => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const { row, column } = node;\n  if (row > 0) neighbors.push(grid[row - 1][column]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n  if (column > 0) neighbors.push(grid[row][column - 1]);\n  if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (node, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.status === 'weight') {\n      neighbor.distance = node.distance + 10;\n    } else {\n      neighbor.distance = node.distance + 1;\n    }\n    neighbor.previousNode = node;\n  }\n};\n\nexport const getNodesInShortestPath = target => {\n  const nodesInShortestPath = [];\n  let currentNode = target;\n  while (currentNode !== null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPath;\n};\n","export const astar = (grid, start, target) => {\n  if (!start || !target) {\n    return;\n  }\n  const unvisitedNodes = [];\n  const visitedNodesInOrder = [];\n\n  start.distance = 0;\n  unvisitedNodes.push(start);\n\n  while (!!unvisitedNodes.length) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === target) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    let neighbours = getNeighbours(closestNode, grid);\n\n    for (let neighbour of neighbours) {\n      let distance;\n      if (closestNode.status === 'weight') {\n        distance = closestNode.distance + 15;\n      } else {\n        distance = closestNode.distance + 1;\n      }\n\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + calculatedManhattanDistance(neighbour, target);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + calculatedManhattanDistance(neighbour, target);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, column } = node;\n  if (column !== grid[0].length - 1) neighbours.push(grid[row][column + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][column]);\n  if (column !== 0) neighbours.push(grid[row][column - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][column]);\n  return neighbours.filter(\n    neighbour => neighbour.status !== 'wall' && !neighbour.isVisited\n  );\n};\n\nconst neighbourNotInUnvisitedNodes = (neighbour, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.column === neighbour.column) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst calculatedManhattanDistance = (node, target) => {\n  const x = Math.abs(node.row - target.row);\n  const y = Math.abs(node.column - target.column);\n  return x + y;\n};\n\nexport const nodesInShortestPathAstar = target => {\n  const nodesInShortestPath = [];\n  let currentNode = target;\n  while (currentNode !== null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPath;\n};\n","export const depthFirstSearch = (grid, start, target) => {\n  const unvisitedNodes = [];\n  const visitedNodesInOrder = [];\n  unvisitedNodes.push(start);\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.status === 'wall') continue;\n    if (closestNode === target) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    const unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, column } = node;\n  if (column !== 0) neighbours.push(grid[row][column - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][column]);\n  if (column !== grid[0].length - 1) neighbours.push(grid[row][column + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][column]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n};\n\nexport const nodesInShortestPathDfs = target => {\n  const nodesInShortestPath = [];\n  let currentNode = target;\n  while (currentNode !== null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPath;\n};\n","export const randomMaze = (grid, start, target) => {\n  if (!start || !target) {\n    return false;\n  }\n\n  let walls = [];\n  grid.forEach(row => {\n    row.forEach(node => {\n      if (\n        !(\n          (node.row === start.row && node.column === start.column) ||\n          (node.row === target.row && node.column === target.column)\n        )\n      ) {\n        if (Math.random() < 0.3) {\n          walls.push([node.row, node.column]);\n        }\n      }\n    });\n  });\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n};\n","import React, { useState, Fragment, useEffect } from 'react';\nimport Node from './Node';\nimport Menu from './Menu';\nimport Info from './Info';\nimport Tutorial from './Tutorial';\nimport styles from '../assets/styles/Board.css';\n\nimport { dijkstra, getNodesInShortestPath } from '../algorithms/dijkstra';\nimport { astar, nodesInShortestPathAstar } from '../algorithms/astar';\nimport {\n  depthFirstSearch,\n  nodesInShortestPathDfs,\n} from '../algorithms/depthfirstsearch';\nimport { recursiveDivision } from '../algorithms/recursiveDivison';\nimport { randomMaze } from '../algorithms/randomMaze';\n\nconst Board = () => {\n  // State for which algorithm is chosen\n  const [algorithm, setAlgorithm] = useState('');\n  // State for algorithm speed\n  const [algorithmSpeed, setAlgorithmSpeed] = useState('Fast');\n  const [speedValue, setSpeedValue] = useState(10);\n\n  // State for  tutoria popup\n  const [showTutorial, setShowTutorial] = useState(true);\n\n  // Calculates number of rows and columns based on window height\n  const height = document.documentElement.clientHeight;\n  const width = document.documentElement.clientWidth;\n\n  // Calculates how many rows and columns the grid should contain, x or y / 30 where 30 is the pixel size of each node\n  let calculatedRows = Math.floor(height / 30) - 7;\n  let calculatedColumns = Math.floor(width / 30);\n\n  // Initial start node coordinates - sets the start row to be in the middle and the column to be on the left side\n  const initialStartRow = Math.floor(calculatedRows / 2);\n  const initialStartColumn = Math.floor(calculatedColumns / 4);\n\n  // Initial target node coordinates - sets the target row to be in the middle and the column to be on the right side\n  const initialTargetRow = Math.floor(calculatedRows / 2);\n  const initialTargetColumn = Math.floor((3 * calculatedColumns) / 4);\n\n  // Creates initial nodes for the grid state\n  const createNode = (row, column) => {\n    return {\n      row,\n      column,\n      status:\n        row === initialStartRow && column === initialStartColumn\n          ? 'start'\n          : row === initialTargetRow && column === initialTargetColumn\n          ? 'target'\n          : '',\n      isVisited: false,\n      distance: Infinity,\n      totalDistance: Infinity,\n      previousNode: null,\n      shortest: false,\n    };\n  };\n\n  // Creates the initial grid to use in state\n  const createInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < calculatedRows; row++) {\n      const currentRow = [];\n      for (let column = 0; column < calculatedColumns; column++) {\n        currentRow.push(createNode(row, column));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  // Stores the grid in state\n  const [grid, setGrid] = useState(createInitialGrid);\n\n  // State of when the startNode is pressed\n  const [isStartNodePressed, setIsStartNodePressed] = useState(false);\n\n  // State of when the targetNode is pressed\n  const [isTargetNodePressed, setIsTargetNodePressed] = useState(false);\n\n  // State of when an empty / wall node is pressed\n  const [pressedNode, setPressedNode] = useState(false);\n\n  // Keeps track of the previous coordinates of the start node\n  // so the previous start nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with start nodes\n  const [prevCoordinates, setPrevCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores the coordinates of the start node\n  const [currentStartCoordinates, setCurrentStartCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores coordinates of target node\n  const [currentTargetCoordinates, setCurrentTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the previous coordinates of the target node\n  // so the previous target nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with target nodes\n  const [prevTargetCoordinates, setPrevTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the status of the node two steps back from the start node (in this case)\n  // - this is made so that the start node never has the same position as the target node, instead it skips it to the next node.\n  const [nodeTwoStepsBack, setNodeTwoStepsBack] = useState([\n    prevCoordinates[0],\n    prevCoordinates[1],\n  ]);\n\n  // Keeps track of the status of the node two steps back from the target node (in this case)\n  // - this is made so that the target node never has the same position as the start node, instead it skips it to the next node.\n  const [targetTwoStepsBack, setTargetTwoStepsBack] = useState([\n    prevTargetCoordinates[0],\n    prevTargetCoordinates[1],\n  ]);\n\n  // Checks whether the start/target node is currently on a wall node - if it is, the wall node is temporarily replaces with the\n  // start/target node. Once the start/target node leaves the wall node, it is re-rendered into a wall node again.\n  const [isOnWallNode, setIsOnWallNode] = useState(false);\n  const [isOnWeightNode, setIsOnWeightNode] = useState(false);\n\n  // Checks if the algorithm animation is done\n  const [algoDone, setAlgoDone] = useState(false);\n  // Disables functionality while algo is running\n  const [disable, setDisable] = useState(false);\n\n  const weightKeyPressed = useKeyPress('w');\n\n  // COMMENT ABOUT LINE 119 - 179 -> these functions make it possible to see the dijkstras algorithm\n  // for the new position of the start / target node when moving the start/target node. Seemed a bit overkill to do this functionality\n  // So I decided to run with a version which clears the grid when moving the start/target node instead.\n\n  // const removeStatic = grid => {\n  //   grid.forEach(row => {\n  //     row.forEach(node => {\n  //       const nodeById = document.getElementById(`${node.row}-${node.column}`);\n  //       nodeById.classList.remove('visited-reset');\n  //       nodeById.classList.remove('shortest-reset');\n  //       if (node.status === 'target') {\n  //         nodeById.classList.remove('start');\n  //       }\n  //     });\n  //   });\n  //   setAlgoDone(false);\n  // };\n\n  // const shortestPath = nodesInShortestPath => {\n  //   for (let i = 0; i < nodesInShortestPath.length; i++) {\n  //     const node = nodesInShortestPath[i];\n  //     const previousNode = nodesInShortestPath[i - 1];\n  //     if (node.status === 'target') {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset target start';\n  //     } else {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset start';\n  //     }\n\n  //     if (previousNode && previousNode.status !== 'start') {\n  //       document\n  //         .getElementById(`${previousNode.row}-${previousNode.column}`)\n  //         .classList.remove('start');\n  //     }\n  //   }\n  // };\n\n  // const runStaticDijkstra = () => {\n  //   resetGrid();\n  //   // removePattern(grid);\n  //   const visitedNodesInOrder = dijkstra(\n  //     grid,\n  //     grid[currentStartCoordinates[0]][currentStartCoordinates[1]],\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   const nodesInShortestPath = getNodesInShortestPath(\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n  //     if (i === visitedNodesInOrder.length) {\n  //       shortestPath(nodesInShortestPath);\n  //     }\n  //     const node = visitedNodesInOrder[i];\n  //     if (node) {\n  //       if (node.status === 'start') {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node start visited-reset';\n  //       } else {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node visited-reset';\n  //       }\n  //     }\n  //   }\n  // };\n\n  // Function to move the start node on mouse enter.\n  // Replaces old start node with a normal node,\n  // then adds the new start node to the current position in the grid\n  // Returns a new grid with updated start node\n  const moveStartNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode = grid[prevCoordinates[0]][prevCoordinates[1]];\n    const twoStepsBack = grid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'start' && previousNode.status === 'target') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n        distance: Infinity,\n        isVisited: false,\n        shortest: false,\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (currentNode.status === 'weight') {\n      setIsOnWeightNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'start' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        isVisited: false,\n        status: '',\n      };\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'start') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current start node\n  const getStartNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'start') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  // Function to move the target node on mouse enter. (same as moveStartNode)\n  // Replaces old target node with a normal node,\n  // then adds the new target node to the current position in the grid\n  // Returns a new grid with updated target node\n  const moveTargetNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode =\n      grid[prevTargetCoordinates[0]][prevTargetCoordinates[1]];\n    const twoStepsBack = grid[targetTwoStepsBack[0]][targetTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'target' && previousNode.status === 'start') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[targetTwoStepsBack[0]][targetTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'target' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        status: '',\n      };\n\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'target') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current target node\n  const getTargetNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'target') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  //Allows to build walls when mouse is held over the nodes\n  const buildWalls = (grid, row, column) => {\n    const node = grid[row][column];\n    if (weightKeyPressed && algorithm !== 'dfs') {\n      if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('weight');\n      } else if (node.status === 'weight') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('weight');\n      }\n    } else {\n      if (node.status === 'wall') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('wall');\n      } else if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('wall');\n      }\n    }\n  };\n\n  const updateWalls = grid => {\n    const newGrid = grid.slice();\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        if (nodeById.classList.contains('weight')) {\n          let newNode = {\n            ...node,\n            status: 'weight',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n        if (nodeById.classList.contains('wall')) {\n          let newNode = {\n            ...node,\n            status: 'wall',\n          };\n          newGrid[node.row][node.column] = newNode;\n        } else if (nodeById.className === 'node') {\n          let newNode = {\n            ...node,\n            status: '',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n      });\n    });\n    setGrid(newGrid);\n  };\n\n  // Runs a function based on which node is pressed\n  const handleMouseDown = (row, column) => {\n    // removePattern(grid);\n    // resetGrid();\n\n    if (getStartNode(grid, row, column) && !disable) {\n      setIsStartNodePressed(true);\n    } else if (getTargetNode(grid, row, column) && !disable) {\n      setIsTargetNodePressed(true);\n    } else if (!disable) {\n      setPressedNode(true);\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // Checks which node is pressed, and runs a function accordingly. Stops running when the node is released (onmouseup).\n  const handleMouseEnter = (row, column) => {\n    if (!isStartNodePressed && !isTargetNodePressed && !pressedNode) return;\n\n    if (isStartNodePressed) {\n      setNodeTwoStepsBack([prevCoordinates[0], prevCoordinates[1]]);\n\n      setPrevCoordinates([row, column]);\n      setCurrentStartCoordinates([row, column]);\n      if (grid[row][column].status !== 'target') {\n        const newGrid = moveStartNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (isTargetNodePressed) {\n      setTargetTwoStepsBack([\n        prevTargetCoordinates[0],\n        prevTargetCoordinates[1],\n      ]);\n      setPrevTargetCoordinates([row, column]);\n      setCurrentTargetCoordinates([row, column]);\n      if (grid[row][column].status !== 'start') {\n        const newGrid = moveTargetNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (pressedNode) {\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // No longer clicking, stop moving start/target node or stop building walls\n  const handleMouseUp = () => {\n    setPressedNode(false);\n    setIsStartNodePressed(false);\n    setIsTargetNodePressed(false);\n    updateWalls(grid);\n  };\n\n  // Visualizes Dijkstras algorithm\n  const visualizeDijkstras = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = dijkstra(grid, start, target);\n\n      const nodesInShortestPath = getNodesInShortestPath(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n\n// Visualizes A* Search algorithm\n  const visualizeAstar = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = astar(grid, start, target);\n\n      const nodesInShortestPath = nodesInShortestPathAstar(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n\n  // Visualizes Depth-first Search algorithm\n  const visualizeDfs = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n      const visitedNodesInOrder = depthFirstSearch(grid, start, target);\n      const nodesInShortestPath = nodesInShortestPathDfs(target);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPath) => {\n    setDisable(true);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPath);\n        }, speedValue * i);\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node) {\n          if (node.status === 'target') {\n            setAlgoDone(true);\n          }\n\n          if (node.status === 'start') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node start visited';\n          } else if (node.status === 'weight') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited weight';\n          } else {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited';\n          }\n        }\n      }, speedValue * i);\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPath => {\n    for (let i = 0; i < nodesInShortestPath.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPath[i];\n        const previousNode = nodesInShortestPath[i - 1];\n\n        if (node.status === 'target') {\n          setDisable(false);\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path target start';\n        } else {\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path start';\n        }\n\n        if (previousNode && previousNode.status !== 'start') {\n          document\n            .getElementById(`${previousNode.row}-${previousNode.column}`)\n            .classList.remove('start');\n        }\n      }, 50 * i);\n    }\n  };\n\n  const clearWalls = grid => {\n    if (!disable) {\n      removePattern(grid);\n      const newGrid = grid.slice();\n      grid.forEach(row => {\n        row.forEach(node => {\n          if (node.status === 'wall') {\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.status === 'weight') {\n            document\n              .getElementById(`${node.row}-${node.column}`)\n              .classList.remove('weight');\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.isVisited) {\n            let newNode = {\n              ...node,\n              isVisited: false,\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n        });\n      });\n      setGrid(newGrid);\n    }\n  };\n\n\n  // Removes the visited nodes pattern\n  const removePattern = grid => {\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        nodeById.classList.remove('visited');\n        nodeById.classList.remove('node-shortest-path');\n        if (node.status === 'target') {\n          nodeById.classList.remove('start');\n        }\n      });\n    });\n    setAlgoDone(false);\n  };\n\n\n  // Resets the nodes (not start or target positions)\n  const resetGrid = grid => {\n    const newGrid = grid.slice();\n\n    grid.forEach(row => {\n      row.forEach(node => {\n        let newNode = {\n          ...node,\n          isVisited: false,\n          shortest: false,\n          distance: Infinity,\n          totalDistance: Infinity,\n          previousNode: null,\n        };\n        newGrid[node.row][node.column] = newNode;\n      });\n    });\n\n    setGrid(newGrid);\n  };\n\n  // Resets the entire board(even start and target node positions)\n  const resetAll = () => {\n    if (!disable) {\n      removePattern(grid);\n      clearWalls(grid);\n      const newGrid = createInitialGrid();\n      setCurrentStartCoordinates([initialStartRow, initialStartColumn]);\n      setCurrentTargetCoordinates([initialTargetRow, initialTargetColumn]);\n      setPrevCoordinates([initialStartRow, initialStartColumn]);\n      setPrevTargetCoordinates([initialTargetRow, initialTargetColumn]);\n\n      newGrid.forEach(row => {\n        row.forEach(node => {\n          let newNode = {\n            ...node,\n            status:\n              node.row === initialStartRow && node.column === initialStartColumn\n                ? 'start'\n                : node.row === initialTargetRow &&\n                  node.column === initialTargetColumn\n                ? 'target'\n                : '',\n            isVisited: false,\n            shortest: false,\n            distance: Infinity,\n            previousNode: null,\n          };\n          newGrid[node.row][node.column] = newNode;\n        });\n      });\n\n      setGrid(newGrid);\n    }\n  };\n\n\n  // Starts visualizing the algorithm based on which one is picked\n  const startVisualize = () => {\n    if (algorithm === 'dijkstra') {\n      visualizeDijkstras();\n    } else if (algorithm === 'astar') {\n      visualizeAstar();\n    } else if (algorithm === 'dfs') {\n      visualizeDfs();\n    }\n  };\n\n  const getGridWithMaze = (grid, walls) => {\n    const newGrid = grid.slice();\n    for (let wall of walls) {\n      let node = grid[wall[0]][wall[1]];\n\n      let newNode = {\n        ...node,\n        status: 'wall',\n      };\n      newGrid[wall[0]][wall[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const getGridWithWeightMaze = (grid, weights) => {\n    const newGrid = grid.slice();\n    for (let weight of weights) {\n      let node = grid[weight[0]][weight[1]];\n\n      let newNode = {\n        ...node,\n        status: 'weight',\n      };\n      newGrid[weight[0]][weight[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const animateMaze = (grid, walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithMaze(grid, walls);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const wall = walls[i];\n      const node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node wall';\n      }, 20 * i);\n    }\n  };\n\n  const animateWeightMaze = (grid, weights) => {\n    for (let i = 0; i <= weights.length; i++) {\n      if (i === weights.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithWeightMaze(grid, weights);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const weight = weights[i];\n      const node = grid[weight[0]][weight[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node weight';\n      }, 20 * i);\n    }\n  };\n\n\n  // Animates recursive divison maze with walls\n  const recursiveDivisionMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n        setDisable(true);\n\n        const walls = recursiveDivision(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n  // Animates random maze with walls\n  const buildRandomMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const walls = randomMaze(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n\n  // Animates random maze with weights\n  const buildRandomWeightMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        setDisable(true);\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const weights = randomMaze(grid, start, target);\n\n        animateWeightMaze(grid, weights);\n      }, 20);\n    }\n  };\n\n  return (\n    <Fragment>\n      <Menu\n        resetAll={() => resetAll()}\n        startVisualize={() => startVisualize()}\n        disable={disable}\n        setDisable={setDisable}\n        algorithm={algorithm}\n        setAlgorithm={e => setAlgorithm(e)}\n        algorithmSpeed={algorithmSpeed}\n        setAlgorithmSpeed={e => setAlgorithmSpeed(e)}\n        speedValue={speedValue}\n        setSpeedValue={e => setSpeedValue(e)}\n        clearWalls={() => clearWalls(grid)}\n        recursiveDivisionMaze={() => recursiveDivisionMaze()}\n        buildRandomMaze={() => buildRandomMaze()}\n        buildRandomWeightMaze={() => buildRandomWeightMaze()}\n        showTutorial={showTutorial}\n        setShowTutorial={e => setShowTutorial(e)}\n      />\n\n      <Tutorial\n        showTutorial={showTutorial}\n        setShowTutorial={() => setShowTutorial()}\n      />\n      <div className='container'>\n        <table className={styles.grid}>\n          <tbody>\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, column, status, isVisited, shortest } = node;\n\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        shortest={shortest}\n                        row={row}\n                        column={column}\n                        status={status}\n                        isVisited={isVisited}\n                        isStartNodePressed={isStartNodePressed}\n                        isTargetNodePressed={isTargetNodePressed}\n                        pressedNode={pressedNode}\n                        onMouseDown={(row, column) =>\n                          handleMouseDown(row, column)\n                        }\n                        onMouseEnter={(row, column) =>\n                          handleMouseEnter(row, column)\n                        }\n                        onMouseUp={(row, column) => handleMouseUp(row, column)}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n      <Info algorithm={algorithm} setAlgorithm={setAlgorithm} />\n    </Fragment>\n  );\n};\n\n\n// Funtion used  to check if \"W\"-key is pressed. Used to build weights (can be used for other keys as well, not just \"W\"-key)\nfunction useKeyPress(targetKey) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // If pressed key is our target key then set to true\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  // If released key is our target key then set to false\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n\nexport default Board;\n","import React from 'react';\nimport Board from './components/Board';\n\nimport './assets/styles/styles.css';\n\nfunction App() {\n  return (\n    <div className='App'>\n      <Board />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}