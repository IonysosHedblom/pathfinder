[{"/Users/ion/Desktop/pathfinder/src/components/Menu.jsx":"1","/Users/ion/Desktop/pathfinder/src/components/Board.jsx":"2","/Users/ion/Desktop/pathfinder/src/algorithms/dijkstra.js":"3","/Users/ion/Desktop/pathfinder/src/App.js":"4","/Users/ion/Desktop/pathfinder/src/components/Node.jsx":"5","/Users/ion/Desktop/pathfinder/src/index.js":"6","/Users/ion/Desktop/pathfinder/src/algorithms/recursiveDivison.js":"7","/Users/ion/Desktop/pathfinder/src/components/Info.jsx":"8","/Users/ion/Desktop/pathfinder/src/algorithms/randomMaze.js":"9","/Users/ion/Desktop/pathfinder/src/algorithms/astar.js":"10","/Users/ion/Desktop/pathfinder/src/algorithms/depthfirstsearch.js":"11","/Users/ion/Desktop/pathfinder/src/components/Tutorial.jsx":"12"},{"size":4904,"mtime":1610136724604,"results":"13","hashOfConfig":"14"},{"size":28675,"mtime":1610131210849,"results":"15","hashOfConfig":"14"},{"size":2115,"mtime":1610057860356,"results":"16","hashOfConfig":"14"},{"size":229,"mtime":1610130591708,"results":"17","hashOfConfig":"14"},{"size":741,"mtime":1609603487694,"results":"18","hashOfConfig":"14"},{"size":199,"mtime":1609006971804,"results":"19","hashOfConfig":"14"},{"size":3120,"mtime":1609936764589,"results":"20","hashOfConfig":"14"},{"size":1375,"mtime":1610081145708,"results":"21","hashOfConfig":"14"},{"size":526,"mtime":1609949255394,"results":"22","hashOfConfig":"14"},{"size":2505,"mtime":1610056885539,"results":"23","hashOfConfig":"14"},{"size":1408,"mtime":1610009029250,"results":"24","hashOfConfig":"14"},{"size":2803,"mtime":1610196564430,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"mu6geb",{"filePath":"28","messages":"29","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"37"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/ion/Desktop/pathfinder/src/components/Menu.jsx",["56","57"],"/Users/ion/Desktop/pathfinder/src/components/Board.jsx",["58","59","60","61"],"import React, { useState, Fragment, useEffect, useCallback } from 'react';\nimport Node from './Node';\nimport Menu from './Menu';\nimport Info from './Info';\nimport Tutorial from './Tutorial';\nimport styles from '../assets/styles/Board.css';\n\nimport { dijkstra, getNodesInShortestPath } from '../algorithms/dijkstra';\nimport { astar, nodesInShortestPathAstar } from '../algorithms/astar';\nimport {\n  depthFirstSearch,\n  nodesInShortestPathDfs,\n} from '../algorithms/depthfirstsearch';\nimport { recursiveDivision } from '../algorithms/recursiveDivison';\nimport { randomMaze } from '../algorithms/randomMaze';\n\nconst Board = () => {\n  // State for which algorithm is chosen\n  const [algorithm, setAlgorithm] = useState('');\n  // State for algorithm speed\n  const [algorithmSpeed, setAlgorithmSpeed] = useState('Fast');\n  const [speedValue, setSpeedValue] = useState(10);\n\n  // State for  tutoria popup\n  const [showTutorial, setShowTutorial] = useState(false);\n\n  // Calculates number of rows and columns based on window height\n  const height = document.documentElement.clientHeight;\n  const width = document.documentElement.clientWidth;\n\n  // Calculates how many rows and columns the grid should contain, x or y / 30 where 30 is the pixel size of each node\n  let calculatedRows = Math.floor(height / 30) - 7;\n  let calculatedColumns = Math.floor(width / 30);\n\n  // Initial start node coordinates - sets the start row to be in the middle and the column to be on the left side\n  const initialStartRow = Math.floor(calculatedRows / 2);\n  const initialStartColumn = Math.floor(calculatedColumns / 4);\n\n  // Initial target node coordinates - sets the target row to be in the middle and the column to be on the right side\n  const initialTargetRow = Math.floor(calculatedRows / 2);\n  const initialTargetColumn = Math.floor((3 * calculatedColumns) / 4);\n\n  // Creates initial nodes for the grid state\n  const createNode = (row, column) => {\n    return {\n      row,\n      column,\n      status:\n        row === initialStartRow && column === initialStartColumn\n          ? 'start'\n          : row === initialTargetRow && column === initialTargetColumn\n          ? 'target'\n          : '',\n      isVisited: false,\n      distance: Infinity,\n      totalDistance: Infinity,\n      previousNode: null,\n      shortest: false,\n    };\n  };\n\n  // Creates the initial grid to use in state\n  const createInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < calculatedRows; row++) {\n      const currentRow = [];\n      for (let column = 0; column < calculatedColumns; column++) {\n        currentRow.push(createNode(row, column));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  // Stores the grid in state\n  const [grid, setGrid] = useState(createInitialGrid);\n\n  // State of when the startNode is pressed\n  const [isStartNodePressed, setIsStartNodePressed] = useState(false);\n\n  // State of when the targetNode is pressed\n  const [isTargetNodePressed, setIsTargetNodePressed] = useState(false);\n\n  // State of when an empty / wall node is pressed\n  const [pressedNode, setPressedNode] = useState(false);\n\n  // Keeps track of the previous coordinates of the start node\n  // so the previous start nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with start nodes\n  const [prevCoordinates, setPrevCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores the coordinates of the start node\n  const [currentStartCoordinates, setCurrentStartCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores coordinates of target node\n  const [currentTargetCoordinates, setCurrentTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the previous coordinates of the target node\n  // so the previous target nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with target nodes\n  const [prevTargetCoordinates, setPrevTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the status of the node two steps back from the start node (in this case)\n  // - this is made so that the start node never has the same position as the target node, instead it skips it to the next node.\n  const [nodeTwoStepsBack, setNodeTwoStepsBack] = useState([\n    prevCoordinates[0],\n    prevCoordinates[1],\n  ]);\n\n  // Keeps track of the status of the node two steps back from the target node (in this case)\n  // - this is made so that the target node never has the same position as the start node, instead it skips it to the next node.\n  const [targetTwoStepsBack, setTargetTwoStepsBack] = useState([\n    prevTargetCoordinates[0],\n    prevTargetCoordinates[1],\n  ]);\n\n  // Checks whether the start/target node is currently on a wall node - if it is, the wall node is temporarily replaces with the\n  // start/target node. Once the start/target node leaves the wall node, it is re-rendered into a wall node again.\n  const [isOnWallNode, setIsOnWallNode] = useState(false);\n  const [isOnWeightNode, setIsOnWeightNode] = useState(false);\n\n  // Checks if the algorithm animation is done\n  const [algoDone, setAlgoDone] = useState(false);\n  // Disables functionality while algo is running\n  const [disable, setDisable] = useState(false);\n\n  const weightKeyPressed = useKeyPress('w');\n\n  // COMMENT ABOUT LINE 119 - 179 -> these functions make it possible to see the dijkstras algorithm\n  // for the new position of the start / target node when moving it. Seemed a bit overkill to do this functionality\n  // So I decided to run with a version which clears the grid when moving the start/target node instead.\n\n  // const removeStatic = grid => {\n  //   grid.forEach(row => {\n  //     row.forEach(node => {\n  //       const nodeById = document.getElementById(`${node.row}-${node.column}`);\n  //       nodeById.classList.remove('visited-reset');\n  //       nodeById.classList.remove('shortest-reset');\n  //       if (node.status === 'target') {\n  //         nodeById.classList.remove('start');\n  //       }\n  //     });\n  //   });\n  //   setAlgoDone(false);\n  // };\n\n  // const shortestPath = nodesInShortestPath => {\n  //   for (let i = 0; i < nodesInShortestPath.length; i++) {\n  //     const node = nodesInShortestPath[i];\n  //     const previousNode = nodesInShortestPath[i - 1];\n  //     if (node.status === 'target') {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset target start';\n  //     } else {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset start';\n  //     }\n\n  //     if (previousNode && previousNode.status !== 'start') {\n  //       document\n  //         .getElementById(`${previousNode.row}-${previousNode.column}`)\n  //         .classList.remove('start');\n  //     }\n  //   }\n  // };\n\n  // const runStaticDijkstra = () => {\n  //   resetGrid();\n  //   // removePattern(grid);\n  //   const visitedNodesInOrder = dijkstra(\n  //     grid,\n  //     grid[currentStartCoordinates[0]][currentStartCoordinates[1]],\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   const nodesInShortestPath = getNodesInShortestPath(\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n  //     if (i === visitedNodesInOrder.length) {\n  //       shortestPath(nodesInShortestPath);\n  //     }\n  //     const node = visitedNodesInOrder[i];\n  //     if (node) {\n  //       if (node.status === 'start') {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node start visited-reset';\n  //       } else {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node visited-reset';\n  //       }\n  //     }\n  //   }\n  // };\n\n  // Function to move the start node on mouse enter.\n  // Replaces old start node with a normal node,\n  // then adds the new start node to the current position in the grid\n  // Returns a new grid with updated start node\n  const moveStartNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode = grid[prevCoordinates[0]][prevCoordinates[1]];\n    const twoStepsBack = grid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'start' && previousNode.status === 'target') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n        distance: Infinity,\n        isVisited: false,\n        shortest: false,\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (currentNode.status === 'weight') {\n      setIsOnWeightNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'start' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        isVisited: false,\n        status: '',\n      };\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'start') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current start node\n  const getStartNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'start') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  // Function to move the target node on mouse enter. (same as moveStartNode)\n  // Replaces old target node with a normal node,\n  // then adds the new target node to the current position in the grid\n  // Returns a new grid with updated target node\n  const moveTargetNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode =\n      grid[prevTargetCoordinates[0]][prevTargetCoordinates[1]];\n    const twoStepsBack = grid[targetTwoStepsBack[0]][targetTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'target' && previousNode.status === 'start') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[targetTwoStepsBack[0]][targetTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'target' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        status: '',\n      };\n\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'target') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current target node\n  const getTargetNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'target') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  //Allows to build walls when mouse is held over the nodes\n  const buildWalls = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const node = grid[row][column];\n    if (weightKeyPressed && algorithm !== 'dfs') {\n      if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('weight');\n      } else if (node.status === 'weight') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('weight');\n      }\n    } else {\n      if (node.status === 'wall') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('wall');\n      } else if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('wall');\n      }\n    }\n  };\n\n  const updateWalls = grid => {\n    const newGrid = grid.slice();\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        if (nodeById.classList.contains('weight')) {\n          let newNode = {\n            ...node,\n            status: 'weight',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n        if (nodeById.classList.contains('wall')) {\n          let newNode = {\n            ...node,\n            status: 'wall',\n          };\n          newGrid[node.row][node.column] = newNode;\n        } else if (nodeById.className === 'node') {\n          let newNode = {\n            ...node,\n            status: '',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n      });\n    });\n    setGrid(newGrid);\n  };\n\n  // Runs a function based on which node is pressed\n  const handleMouseDown = (row, column) => {\n    // removePattern(grid);\n    // resetGrid();\n\n    if (getStartNode(grid, row, column) && !disable) {\n      setIsStartNodePressed(true);\n    } else if (getTargetNode(grid, row, column) && !disable) {\n      setIsTargetNodePressed(true);\n    } else if (!disable) {\n      setPressedNode(true);\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // Checks which node is pressed, and runs a function accordingly. Stops running when the node is released (onmouseup).\n  const handleMouseEnter = (row, column) => {\n    if (!isStartNodePressed && !isTargetNodePressed && !pressedNode) return;\n\n    if (isStartNodePressed) {\n      setNodeTwoStepsBack([prevCoordinates[0], prevCoordinates[1]]);\n\n      setPrevCoordinates([row, column]);\n      setCurrentStartCoordinates([row, column]);\n      if (grid[row][column].status !== 'target') {\n        const newGrid = moveStartNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (isTargetNodePressed) {\n      setTargetTwoStepsBack([\n        prevTargetCoordinates[0],\n        prevTargetCoordinates[1],\n      ]);\n      setPrevTargetCoordinates([row, column]);\n      setCurrentTargetCoordinates([row, column]);\n      if (grid[row][column].status !== 'start') {\n        const newGrid = moveTargetNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (pressedNode) {\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // No longer clicking, stop moving start/target node or stop building walls\n  const handleMouseUp = () => {\n    setPressedNode(false);\n    setIsStartNodePressed(false);\n    setIsTargetNodePressed(false);\n    updateWalls(grid);\n  };\n\n  // Visualizes Dijkstras algorithm\n  const visualizeDijkstras = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = dijkstra(grid, start, target);\n\n      const nodesInShortestPath = getNodesInShortestPath(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n  const visualizeAstar = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = astar(grid, start, target);\n\n      const nodesInShortestPath = nodesInShortestPathAstar(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n  const visualizeDfs = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n      const visitedNodesInOrder = depthFirstSearch(grid, start, target);\n      const nodesInShortestPath = nodesInShortestPathDfs(target);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPath) => {\n    setDisable(true);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPath);\n        }, speedValue * i);\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node) {\n          if (node.status === 'target') {\n            setAlgoDone(true);\n          }\n\n          if (node.status === 'start') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node start visited';\n          } else if (node.status === 'weight') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited weight';\n          } else {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited';\n          }\n        }\n      }, speedValue * i);\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPath => {\n    for (let i = 0; i < nodesInShortestPath.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPath[i];\n        const previousNode = nodesInShortestPath[i - 1];\n\n        if (node.status === 'target') {\n          setDisable(false);\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path target start';\n        } else {\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path start';\n        }\n\n        if (previousNode && previousNode.status !== 'start') {\n          document\n            .getElementById(`${previousNode.row}-${previousNode.column}`)\n            .classList.remove('start');\n        }\n      }, 50 * i);\n    }\n  };\n\n  const clearWalls = grid => {\n    if (!disable) {\n      removePattern(grid);\n      const newGrid = grid.slice();\n      grid.forEach(row => {\n        row.forEach(node => {\n          if (node.status === 'wall') {\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.status === 'weight') {\n            document\n              .getElementById(`${node.row}-${node.column}`)\n              .classList.remove('weight');\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.isVisited) {\n            let newNode = {\n              ...node,\n              isVisited: false,\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n        });\n      });\n      setGrid(newGrid);\n    }\n  };\n\n  const removePattern = grid => {\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        nodeById.classList.remove('visited');\n        nodeById.classList.remove('node-shortest-path');\n        if (node.status === 'target') {\n          nodeById.classList.remove('start');\n        }\n      });\n    });\n    setAlgoDone(false);\n  };\n\n  const resetGrid = grid => {\n    const newGrid = grid.slice();\n\n    grid.forEach(row => {\n      row.forEach(node => {\n        let newNode = {\n          ...node,\n          isVisited: false,\n          shortest: false,\n          distance: Infinity,\n          totalDistance: Infinity,\n          previousNode: null,\n        };\n        newGrid[node.row][node.column] = newNode;\n      });\n    });\n\n    setGrid(newGrid);\n  };\n\n  const resetAll = () => {\n    if (!disable) {\n      removePattern(grid);\n      clearWalls(grid);\n      const newGrid = createInitialGrid();\n      setCurrentStartCoordinates([initialStartRow, initialStartColumn]);\n      setCurrentTargetCoordinates([initialTargetRow, initialTargetColumn]);\n      setPrevCoordinates([initialStartRow, initialStartColumn]);\n      setPrevTargetCoordinates([initialTargetRow, initialTargetColumn]);\n\n      newGrid.forEach(row => {\n        row.forEach(node => {\n          let newNode = {\n            ...node,\n            status:\n              node.row === initialStartRow && node.column === initialStartColumn\n                ? 'start'\n                : node.row === initialTargetRow &&\n                  node.column === initialTargetColumn\n                ? 'target'\n                : '',\n            isVisited: false,\n            shortest: false,\n            distance: Infinity,\n            previousNode: null,\n          };\n          newGrid[node.row][node.column] = newNode;\n        });\n      });\n\n      setGrid(newGrid);\n    }\n  };\n\n  const startVisualize = () => {\n    if (algorithm === 'dijkstra') {\n      visualizeDijkstras();\n    } else if (algorithm === 'astar') {\n      visualizeAstar();\n    } else if (algorithm === 'dfs') {\n      visualizeDfs();\n    }\n  };\n\n  const getGridWithMaze = (grid, walls) => {\n    const newGrid = grid.slice();\n    for (let wall of walls) {\n      let node = grid[wall[0]][wall[1]];\n\n      let newNode = {\n        ...node,\n        status: 'wall',\n      };\n      newGrid[wall[0]][wall[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const getGridWithWeightMaze = (grid, weights) => {\n    const newGrid = grid.slice();\n    for (let weight of weights) {\n      let node = grid[weight[0]][weight[1]];\n\n      let newNode = {\n        ...node,\n        status: 'weight',\n      };\n      newGrid[weight[0]][weight[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const animateMaze = (grid, walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithMaze(grid, walls);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const wall = walls[i];\n      const node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node wall';\n      }, 20 * i);\n    }\n  };\n\n  const animateWeightMaze = (grid, weights) => {\n    for (let i = 0; i <= weights.length; i++) {\n      if (i === weights.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithWeightMaze(grid, weights);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const weight = weights[i];\n      const node = grid[weight[0]][weight[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node weight';\n      }, 20 * i);\n    }\n  };\n\n  const recursiveDivisionMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n        setDisable(true);\n\n        const walls = recursiveDivision(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n  const buildRandomMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const walls = randomMaze(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n  const buildRandomWeightMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        setDisable(true);\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const weights = randomMaze(grid, start, target);\n\n        animateWeightMaze(grid, weights);\n      }, 20);\n    }\n  };\n\n  return (\n    <Fragment>\n      <Menu\n        resetAll={() => resetAll()}\n        startVisualize={() => startVisualize()}\n        disable={disable}\n        setDisable={setDisable}\n        algorithm={algorithm}\n        setAlgorithm={e => setAlgorithm(e)}\n        algorithmSpeed={algorithmSpeed}\n        setAlgorithmSpeed={e => setAlgorithmSpeed(e)}\n        speedValue={speedValue}\n        setSpeedValue={e => setSpeedValue(e)}\n        clearWalls={() => clearWalls(grid)}\n        recursiveDivisionMaze={() => recursiveDivisionMaze()}\n        buildRandomMaze={() => buildRandomMaze()}\n        buildRandomWeightMaze={() => buildRandomWeightMaze()}\n        showTutorial={showTutorial}\n        setShowTutorial={e => setShowTutorial(e)}\n      />\n      <Info algorithm={algorithm} setAlgorithm={setAlgorithm} />\n\n      <Tutorial\n        showTutorial={showTutorial}\n        setShowTutorial={() => setShowTutorial()}\n      />\n      <div className='container'>\n        <table className={styles.grid}>\n          <tbody>\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, column, status, isVisited, shortest } = node;\n\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        shortest={shortest}\n                        row={row}\n                        column={column}\n                        status={status}\n                        isVisited={isVisited}\n                        isStartNodePressed={isStartNodePressed}\n                        isTargetNodePressed={isTargetNodePressed}\n                        pressedNode={pressedNode}\n                        onMouseDown={(row, column) =>\n                          handleMouseDown(row, column)\n                        }\n                        onMouseEnter={(row, column) =>\n                          handleMouseEnter(row, column)\n                        }\n                        onMouseUp={(row, column) => handleMouseUp(row, column)}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </Fragment>\n  );\n};\n\nfunction useKeyPress(targetKey) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // If pressed key is our target key then set to true\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  // If released key is our target key then set to false\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n\nexport default Board;\n","/Users/ion/Desktop/pathfinder/src/algorithms/dijkstra.js",[],["62","63"],"/Users/ion/Desktop/pathfinder/src/App.js",["64"],"import React, { useState } from 'react';\nimport Board from './components/Board';\n\nimport './assets/styles/styles.css';\n\nfunction App() {\n  return (\n    <div className='App'>\n      <Board />\n    </div>\n  );\n}\n\nexport default App;\n",["65","66"],"/Users/ion/Desktop/pathfinder/src/components/Node.jsx",["67"],"import React from 'react';\n\nimport styles from '../assets/styles/Node.css';\n\nconst Node = props => {\n  const {\n    row,\n    column,\n    status,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    shortest,\n  } = props;\n\n  const typeOfNode =\n    status === 'start'\n      ? 'start'\n      : status === 'target'\n      ? 'target'\n      : status === 'wall'\n      ? 'wall'\n      : '';\n\n  const shortestClass = shortest ? 'node-shortest-path' : '';\n\n  return (\n    <td\n      onMouseDown={() => onMouseDown(row, column)}\n      onMouseEnter={() => onMouseEnter(row, column)}\n      onMouseUp={() => onMouseUp(row, column)}\n      className={`node ${typeOfNode} ${shortestClass}`}\n      id={`${row}-${column}`}\n    ></td>\n  );\n};\n\nexport default Node;\n","/Users/ion/Desktop/pathfinder/src/index.js",[],"/Users/ion/Desktop/pathfinder/src/algorithms/recursiveDivison.js",[],"/Users/ion/Desktop/pathfinder/src/components/Info.jsx",[],"/Users/ion/Desktop/pathfinder/src/algorithms/randomMaze.js",[],["68","69"],"/Users/ion/Desktop/pathfinder/src/algorithms/astar.js",[],"/Users/ion/Desktop/pathfinder/src/algorithms/depthfirstsearch.js",[],"/Users/ion/Desktop/pathfinder/src/components/Tutorial.jsx",[],{"ruleId":"70","severity":1,"message":"71","line":62,"column":5,"nodeType":"72","endLine":62,"endColumn":72,"suggestions":"73"},{"ruleId":"70","severity":1,"message":"74","line":71,"column":6,"nodeType":"72","endLine":71,"endColumn":8,"suggestions":"75"},{"ruleId":"76","severity":1,"message":"77","line":1,"column":48,"nodeType":"78","messageId":"79","endLine":1,"endColumn":59},{"ruleId":"76","severity":1,"message":"80","line":130,"column":10,"nodeType":"78","messageId":"79","endLine":130,"endColumn":24},{"ruleId":"76","severity":1,"message":"81","line":371,"column":11,"nodeType":"78","messageId":"79","endLine":371,"endColumn":18},{"ruleId":"70","severity":1,"message":"82","line":915,"column":6,"nodeType":"72","endLine":915,"endColumn":8,"suggestions":"83"},{"ruleId":"84","replacedBy":"85"},{"ruleId":"86","replacedBy":"87"},{"ruleId":"76","severity":1,"message":"88","line":1,"column":17,"nodeType":"78","messageId":"79","endLine":1,"endColumn":25},{"ruleId":"84","replacedBy":"89"},{"ruleId":"86","replacedBy":"90"},{"ruleId":"76","severity":1,"message":"91","line":3,"column":8,"nodeType":"78","messageId":"79","endLine":3,"endColumn":14},{"ruleId":"84","replacedBy":"92"},{"ruleId":"86","replacedBy":"93"},"react-hooks/exhaustive-deps","React Hook useCallback has unnecessary dependencies: 'algoDropdown.current', 'mazeDropdown.current', and 'speedDropdown.current'. Either exclude them or remove the dependency array. Mutable values like 'algoDropdown.current' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["94"],"React Hook useEffect has a missing dependency: 'closeDropdowns'. Either include it or remove the dependency array.",["95"],"no-unused-vars","'useCallback' is defined but never used.","Identifier","unusedVar","'isOnWeightNode' is assigned a value but never used.","'newGrid' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'downHandler' and 'upHandler'. Either include them or remove the dependency array.",["96"],"no-native-reassign",["97"],"no-negated-in-lhs",["98"],"'useState' is defined but never used.",["97"],["98"],"'styles' is defined but never used.",["97"],["98"],{"desc":"99","fix":"100"},{"desc":"101","fix":"102"},{"desc":"103","fix":"104"},"no-global-assign","no-unsafe-negation","Update the dependencies array to be: []",{"range":"105","text":"106"},"Update the dependencies array to be: [closeDropdowns]",{"range":"107","text":"108"},"Update the dependencies array to be: [downHandler, upHandler]",{"range":"109","text":"110"},[1483,1550],"[]",[1726,1728],"[closeDropdowns]",[28555,28557],"[downHandler, upHandler]"]