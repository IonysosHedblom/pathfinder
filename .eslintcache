[{"/Users/ion/Desktop/React/pathfinder/src/index.js":"1","/Users/ion/Desktop/React/pathfinder/src/components/Board.jsx":"2","/Users/ion/Desktop/React/pathfinder/src/components/Info.jsx":"3","/Users/ion/Desktop/React/pathfinder/src/components/Menu.jsx":"4","/Users/ion/Desktop/React/pathfinder/src/algorithms/depthfirstsearch.js":"5","/Users/ion/Desktop/React/pathfinder/src/App.js":"6","/Users/ion/Desktop/React/pathfinder/src/components/Node.jsx":"7","/Users/ion/Desktop/React/pathfinder/src/algorithms/dijkstra.js":"8","/Users/ion/Desktop/React/pathfinder/src/algorithms/randomMaze.js":"9","/Users/ion/Desktop/React/pathfinder/src/algorithms/astar.js":"10","/Users/ion/Desktop/React/pathfinder/src/algorithms/recursiveDivison.js":"11","/Users/ion/Desktop/React/pathfinder/src/components/Tutorial.jsx":"12"},{"size":199,"mtime":1609006971804,"results":"13","hashOfConfig":"14"},{"size":29210,"mtime":1611139720226,"results":"15","hashOfConfig":"14"},{"size":863,"mtime":1610311294581,"results":"16","hashOfConfig":"14"},{"size":4886,"mtime":1610364349750,"results":"17","hashOfConfig":"14"},{"size":1408,"mtime":1610009029250,"results":"18","hashOfConfig":"14"},{"size":215,"mtime":1610306608578,"results":"19","hashOfConfig":"14"},{"size":741,"mtime":1609603487694,"results":"20","hashOfConfig":"14"},{"size":2115,"mtime":1610057860356,"results":"21","hashOfConfig":"14"},{"size":526,"mtime":1609949255394,"results":"22","hashOfConfig":"14"},{"size":2505,"mtime":1610056885539,"results":"23","hashOfConfig":"14"},{"size":3120,"mtime":1609936764589,"results":"24","hashOfConfig":"14"},{"size":6056,"mtime":1610492806631,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1n2ygt5",{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"28"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"28"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/ion/Desktop/React/pathfinder/src/index.js",[],["54","55"],"/Users/ion/Desktop/React/pathfinder/src/components/Board.jsx",["56","57"],"import React, { useState, Fragment, useEffect } from 'react';\nimport Node from './Node';\nimport Menu from './Menu';\nimport Info from './Info';\nimport Tutorial from './Tutorial';\nimport styles from '../assets/styles/Board.css';\n\nimport { dijkstra, getNodesInShortestPath } from '../algorithms/dijkstra';\nimport { astar, nodesInShortestPathAstar } from '../algorithms/astar';\nimport {\n  depthFirstSearch,\n  nodesInShortestPathDfs,\n} from '../algorithms/depthfirstsearch';\nimport { recursiveDivision } from '../algorithms/recursiveDivison';\nimport { randomMaze } from '../algorithms/randomMaze';\n\nconst Board = () => {\n  // State for which algorithm is chosen\n  const [algorithm, setAlgorithm] = useState('');\n  // State for algorithm speed\n  const [algorithmSpeed, setAlgorithmSpeed] = useState('Fast');\n  const [speedValue, setSpeedValue] = useState(10);\n\n  // State for  tutoria popup\n  const [showTutorial, setShowTutorial] = useState(true);\n\n  // Calculates number of rows and columns based on window height\n  const height = document.documentElement.clientHeight;\n  const width = document.documentElement.clientWidth;\n\n  // Calculates how many rows and columns the grid should contain, x or y / 30 where 30 is the pixel size of each node\n  let calculatedRows = Math.floor(height / 30) - 7;\n  let calculatedColumns = Math.floor(width / 30);\n\n  // Initial start node coordinates - sets the start row to be in the middle and the column to be on the left side\n  const initialStartRow = Math.floor(calculatedRows / 2);\n  const initialStartColumn = Math.floor(calculatedColumns / 4);\n\n  // Initial target node coordinates - sets the target row to be in the middle and the column to be on the right side\n  const initialTargetRow = Math.floor(calculatedRows / 2);\n  const initialTargetColumn = Math.floor((3 * calculatedColumns) / 4);\n\n  // Creates initial nodes for the grid state\n  const createNode = (row, column) => {\n    return {\n      row,\n      column,\n      status:\n        row === initialStartRow && column === initialStartColumn\n          ? 'start'\n          : row === initialTargetRow && column === initialTargetColumn\n          ? 'target'\n          : '',\n      isVisited: false,\n      distance: Infinity,\n      totalDistance: Infinity,\n      previousNode: null,\n      shortest: false,\n    };\n  };\n\n  // Creates the initial grid to use in state\n  const createInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < calculatedRows; row++) {\n      const currentRow = [];\n      for (let column = 0; column < calculatedColumns; column++) {\n        currentRow.push(createNode(row, column));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  // Stores the grid in state\n  const [grid, setGrid] = useState(createInitialGrid);\n\n  // State of when the startNode is pressed\n  const [isStartNodePressed, setIsStartNodePressed] = useState(false);\n\n  // State of when the targetNode is pressed\n  const [isTargetNodePressed, setIsTargetNodePressed] = useState(false);\n\n  // State of when an empty / wall node is pressed\n  const [pressedNode, setPressedNode] = useState(false);\n\n  // Keeps track of the previous coordinates of the start node\n  // so the previous start nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with start nodes\n  const [prevCoordinates, setPrevCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores the coordinates of the start node\n  const [currentStartCoordinates, setCurrentStartCoordinates] = useState([\n    initialStartRow,\n    initialStartColumn,\n  ]);\n\n  // Stores coordinates of target node\n  const [currentTargetCoordinates, setCurrentTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the previous coordinates of the target node\n  // so the previous target nodes can be re-rendered into normal or wall nodes - otherwise it leaves a trail with target nodes\n  const [prevTargetCoordinates, setPrevTargetCoordinates] = useState([\n    initialTargetRow,\n    initialTargetColumn,\n  ]);\n\n  // Keeps track of the status of the node two steps back from the start node (in this case)\n  // - this is made so that the start node never has the same position as the target node, instead it skips it to the next node.\n  const [nodeTwoStepsBack, setNodeTwoStepsBack] = useState([\n    prevCoordinates[0],\n    prevCoordinates[1],\n  ]);\n\n  // Keeps track of the status of the node two steps back from the target node (in this case)\n  // - this is made so that the target node never has the same position as the start node, instead it skips it to the next node.\n  const [targetTwoStepsBack, setTargetTwoStepsBack] = useState([\n    prevTargetCoordinates[0],\n    prevTargetCoordinates[1],\n  ]);\n\n  // Checks whether the start/target node is currently on a wall node - if it is, the wall node is temporarily replaces with the\n  // start/target node. Once the start/target node leaves the wall node, it is re-rendered into a wall node again.\n  const [isOnWallNode, setIsOnWallNode] = useState(false);\n  const [isOnWeightNode, setIsOnWeightNode] = useState(false);\n\n  // Checks if the algorithm animation is done\n  const [algoDone, setAlgoDone] = useState(false);\n  // Disables functionality while algo is running\n  const [disable, setDisable] = useState(false);\n\n  const weightKeyPressed = useKeyPress('w');\n\n  // COMMENT ABOUT LINE 119 - 179 -> these functions make it possible to see the dijkstras algorithm\n  // for the new position of the start / target node when moving the start/target node. Seemed a bit overkill to do this functionality\n  // So I decided to run with a version which clears the grid when moving the start/target node instead.\n\n  // const removeStatic = grid => {\n  //   grid.forEach(row => {\n  //     row.forEach(node => {\n  //       const nodeById = document.getElementById(`${node.row}-${node.column}`);\n  //       nodeById.classList.remove('visited-reset');\n  //       nodeById.classList.remove('shortest-reset');\n  //       if (node.status === 'target') {\n  //         nodeById.classList.remove('start');\n  //       }\n  //     });\n  //   });\n  //   setAlgoDone(false);\n  // };\n\n  // const shortestPath = nodesInShortestPath => {\n  //   for (let i = 0; i < nodesInShortestPath.length; i++) {\n  //     const node = nodesInShortestPath[i];\n  //     const previousNode = nodesInShortestPath[i - 1];\n  //     if (node.status === 'target') {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset target start';\n  //     } else {\n  //       document.getElementById(`${node.row}-${node.column}`).className =\n  //         'node shortest-reset start';\n  //     }\n\n  //     if (previousNode && previousNode.status !== 'start') {\n  //       document\n  //         .getElementById(`${previousNode.row}-${previousNode.column}`)\n  //         .classList.remove('start');\n  //     }\n  //   }\n  // };\n\n  // const runStaticDijkstra = () => {\n  //   resetGrid();\n  //   // removePattern(grid);\n  //   const visitedNodesInOrder = dijkstra(\n  //     grid,\n  //     grid[currentStartCoordinates[0]][currentStartCoordinates[1]],\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   const nodesInShortestPath = getNodesInShortestPath(\n  //     grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]]\n  //   );\n  //   for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n  //     if (i === visitedNodesInOrder.length) {\n  //       shortestPath(nodesInShortestPath);\n  //     }\n  //     const node = visitedNodesInOrder[i];\n  //     if (node) {\n  //       if (node.status === 'start') {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node start visited-reset';\n  //       } else {\n  //         document.getElementById(`${node.row}-${node.column}`).className =\n  //           'node visited-reset';\n  //       }\n  //     }\n  //   }\n  // };\n\n  // Function to move the start node on mouse enter.\n  // Replaces old start node with a normal node,\n  // then adds the new start node to the current position in the grid\n  // Returns a new grid with updated start node\n  const moveStartNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode = grid[prevCoordinates[0]][prevCoordinates[1]];\n    const twoStepsBack = grid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'start' && previousNode.status === 'target') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[nodeTwoStepsBack[0]][nodeTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n        distance: Infinity,\n        isVisited: false,\n        shortest: false,\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (currentNode.status === 'weight') {\n      setIsOnWeightNode(true);\n\n      let newNode = {\n        ...currentNode,\n        status: 'start',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'start' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        isVisited: false,\n        status: '',\n      };\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'start') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n\n      newGrid[prevCoordinates[0]][prevCoordinates[1]] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current start node\n  const getStartNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'start') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  // Function to move the target node on mouse enter. (same as moveStartNode)\n  // Replaces old target node with a normal node,\n  // then adds the new target node to the current position in the grid\n  // Returns a new grid with updated target node\n  const moveTargetNode = (grid, row, column) => {\n    const newGrid = grid.slice();\n    const currentNode = grid[row][column];\n    const previousNode =\n      grid[prevTargetCoordinates[0]][prevTargetCoordinates[1]];\n    const twoStepsBack = grid[targetTwoStepsBack[0]][targetTwoStepsBack[1]];\n\n    // Simply removes the old dijkstras pattern if moving start node when algorithm is done running\n    if (algoDone) {\n      removePattern(grid);\n      resetGrid(grid);\n    }\n\n    if (twoStepsBack.status === 'target' && previousNode.status === 'start') {\n      let newNode = {\n        ...twoStepsBack,\n        status: '',\n      };\n      newGrid[targetTwoStepsBack[0]][targetTwoStepsBack[1]] = newNode;\n    }\n\n    if (currentNode.status === '') {\n      setIsOnWallNode(false);\n      setIsOnWeightNode(false);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    } else if (currentNode.status === 'wall') {\n      setIsOnWallNode(true);\n      let newNode = {\n        ...currentNode,\n        status: 'target',\n      };\n\n      newGrid[row][column] = newNode;\n    }\n\n    if (previousNode.status === 'target' && !isOnWallNode) {\n      let newPreviousNode = {\n        ...previousNode,\n        status: '',\n      };\n\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    } else if (isOnWallNode && previousNode.status === 'target') {\n      let newPreviousNode = {\n        ...previousNode,\n        status: 'wall',\n      };\n      newGrid[prevTargetCoordinates[0]][\n        prevTargetCoordinates[1]\n      ] = newPreviousNode;\n    }\n\n    return newGrid;\n  };\n\n  // Checks whether the node at (row, column) is the current target node\n  const getTargetNode = (grid, row, column) => {\n    const node = grid[row][column];\n    if (node.status === 'target') {\n      return node;\n    } else {\n      return false;\n    }\n  };\n\n  //Allows to build walls when mouse is held over the nodes\n  const buildWalls = (grid, row, column) => {\n    const node = grid[row][column];\n    if (weightKeyPressed && algorithm !== 'dfs') {\n      if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('weight');\n      } else if (node.status === 'weight') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('weight');\n      }\n    } else {\n      if (node.status === 'wall') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.remove('wall');\n      } else if (node.status === '') {\n        document\n          .getElementById(`${node.row}-${node.column}`)\n          .classList.add('wall');\n      }\n    }\n  };\n\n  const updateWalls = grid => {\n    const newGrid = grid.slice();\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        if (nodeById.classList.contains('weight')) {\n          let newNode = {\n            ...node,\n            status: 'weight',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n        if (nodeById.classList.contains('wall')) {\n          let newNode = {\n            ...node,\n            status: 'wall',\n          };\n          newGrid[node.row][node.column] = newNode;\n        } else if (nodeById.className === 'node') {\n          let newNode = {\n            ...node,\n            status: '',\n          };\n          newGrid[node.row][node.column] = newNode;\n        }\n      });\n    });\n    setGrid(newGrid);\n  };\n\n  // Runs a function based on which node is pressed\n  const handleMouseDown = (row, column) => {\n    // removePattern(grid);\n    // resetGrid();\n\n    if (getStartNode(grid, row, column) && !disable) {\n      setIsStartNodePressed(true);\n    } else if (getTargetNode(grid, row, column) && !disable) {\n      setIsTargetNodePressed(true);\n    } else if (!disable) {\n      setPressedNode(true);\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // Checks which node is pressed, and runs a function accordingly. Stops running when the node is released (onmouseup).\n  const handleMouseEnter = (row, column) => {\n    if (!isStartNodePressed && !isTargetNodePressed && !pressedNode) return;\n\n    if (isStartNodePressed) {\n      setNodeTwoStepsBack([prevCoordinates[0], prevCoordinates[1]]);\n\n      setPrevCoordinates([row, column]);\n      setCurrentStartCoordinates([row, column]);\n      if (grid[row][column].status !== 'target') {\n        const newGrid = moveStartNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (isTargetNodePressed) {\n      setTargetTwoStepsBack([\n        prevTargetCoordinates[0],\n        prevTargetCoordinates[1],\n      ]);\n      setPrevTargetCoordinates([row, column]);\n      setCurrentTargetCoordinates([row, column]);\n      if (grid[row][column].status !== 'start') {\n        const newGrid = moveTargetNode(grid, row, column);\n        setGrid(newGrid);\n      }\n    } else if (pressedNode) {\n      buildWalls(grid, row, column);\n    }\n  };\n\n  // No longer clicking, stop moving start/target node or stop building walls\n  const handleMouseUp = () => {\n    setPressedNode(false);\n    setIsStartNodePressed(false);\n    setIsTargetNodePressed(false);\n    updateWalls(grid);\n  };\n\n  // Visualizes Dijkstras algorithm\n  const visualizeDijkstras = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = dijkstra(grid, start, target);\n\n      const nodesInShortestPath = getNodesInShortestPath(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n\n// Visualizes A* Search algorithm\n  const visualizeAstar = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n      const visitedNodesInOrder = astar(grid, start, target);\n\n      const nodesInShortestPath = nodesInShortestPathAstar(target);\n\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n\n  // Visualizes Depth-first Search algorithm\n  const visualizeDfs = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      const start =\n        grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n      const target =\n        grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n      const visitedNodesInOrder = depthFirstSearch(grid, start, target);\n      const nodesInShortestPath = nodesInShortestPathDfs(target);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPath);\n    }\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPath) => {\n    setDisable(true);\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPath);\n        }, speedValue * i);\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node) {\n          if (node.status === 'target') {\n            setAlgoDone(true);\n          }\n\n          if (node.status === 'start') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node start visited';\n          } else if (node.status === 'weight') {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited weight';\n          } else {\n            document.getElementById(`${node.row}-${node.column}`).className =\n              'node visited';\n          }\n        }\n      }, speedValue * i);\n    }\n  };\n\n  const animateShortestPath = nodesInShortestPath => {\n    for (let i = 0; i < nodesInShortestPath.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPath[i];\n        const previousNode = nodesInShortestPath[i - 1];\n\n        if (node.status === 'target') {\n          setDisable(false);\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path target start';\n        } else {\n          document.getElementById(`${node.row}-${node.column}`).className =\n            'node node-shortest-path start';\n        }\n\n        if (previousNode && previousNode.status !== 'start') {\n          document\n            .getElementById(`${previousNode.row}-${previousNode.column}`)\n            .classList.remove('start');\n        }\n      }, 50 * i);\n    }\n  };\n\n  const clearWalls = grid => {\n    if (!disable) {\n      removePattern(grid);\n      const newGrid = grid.slice();\n      grid.forEach(row => {\n        row.forEach(node => {\n          if (node.status === 'wall') {\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.status === 'weight') {\n            document\n              .getElementById(`${node.row}-${node.column}`)\n              .classList.remove('weight');\n            let newNode = {\n              ...node,\n              status: '',\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n          if (node.isVisited) {\n            let newNode = {\n              ...node,\n              isVisited: false,\n            };\n            newGrid[node.row][node.column] = newNode;\n          }\n        });\n      });\n      setGrid(newGrid);\n    }\n  };\n\n\n  // Removes the visited nodes pattern\n  const removePattern = grid => {\n    grid.forEach(row => {\n      row.forEach(node => {\n        const nodeById = document.getElementById(`${node.row}-${node.column}`);\n        nodeById.classList.remove('visited');\n        nodeById.classList.remove('node-shortest-path');\n        if (node.status === 'target') {\n          nodeById.classList.remove('start');\n        }\n      });\n    });\n    setAlgoDone(false);\n  };\n\n\n  // Resets the nodes (not start or target positions)\n  const resetGrid = grid => {\n    const newGrid = grid.slice();\n\n    grid.forEach(row => {\n      row.forEach(node => {\n        let newNode = {\n          ...node,\n          isVisited: false,\n          shortest: false,\n          distance: Infinity,\n          totalDistance: Infinity,\n          previousNode: null,\n        };\n        newGrid[node.row][node.column] = newNode;\n      });\n    });\n\n    setGrid(newGrid);\n  };\n\n  // Resets the entire board(even start and target node positions)\n  const resetAll = () => {\n    if (!disable) {\n      removePattern(grid);\n      clearWalls(grid);\n      const newGrid = createInitialGrid();\n      setCurrentStartCoordinates([initialStartRow, initialStartColumn]);\n      setCurrentTargetCoordinates([initialTargetRow, initialTargetColumn]);\n      setPrevCoordinates([initialStartRow, initialStartColumn]);\n      setPrevTargetCoordinates([initialTargetRow, initialTargetColumn]);\n\n      newGrid.forEach(row => {\n        row.forEach(node => {\n          let newNode = {\n            ...node,\n            status:\n              node.row === initialStartRow && node.column === initialStartColumn\n                ? 'start'\n                : node.row === initialTargetRow &&\n                  node.column === initialTargetColumn\n                ? 'target'\n                : '',\n            isVisited: false,\n            shortest: false,\n            distance: Infinity,\n            previousNode: null,\n          };\n          newGrid[node.row][node.column] = newNode;\n        });\n      });\n\n      setGrid(newGrid);\n    }\n  };\n\n\n  // Starts visualizing the algorithm based on which one is picked\n  const startVisualize = () => {\n    if (algorithm === 'dijkstra') {\n      visualizeDijkstras();\n    } else if (algorithm === 'astar') {\n      visualizeAstar();\n    } else if (algorithm === 'dfs') {\n      visualizeDfs();\n    }\n  };\n\n  const getGridWithMaze = (grid, walls) => {\n    const newGrid = grid.slice();\n    for (let wall of walls) {\n      let node = grid[wall[0]][wall[1]];\n\n      let newNode = {\n        ...node,\n        status: 'wall',\n      };\n      newGrid[wall[0]][wall[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const getGridWithWeightMaze = (grid, weights) => {\n    const newGrid = grid.slice();\n    for (let weight of weights) {\n      let node = grid[weight[0]][weight[1]];\n\n      let newNode = {\n        ...node,\n        status: 'weight',\n      };\n      newGrid[weight[0]][weight[1]] = newNode;\n    }\n\n    setGrid(newGrid);\n  };\n\n  const animateMaze = (grid, walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithMaze(grid, walls);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const wall = walls[i];\n      const node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node wall';\n      }, 20 * i);\n    }\n  };\n\n  const animateWeightMaze = (grid, weights) => {\n    for (let i = 0; i <= weights.length; i++) {\n      if (i === weights.length) {\n        resetGrid(grid);\n        clearWalls(grid);\n        setTimeout(() => {\n          getGridWithWeightMaze(grid, weights);\n          setDisable(false);\n        }, 20 * i);\n\n        return;\n      }\n      const weight = weights[i];\n      const node = grid[weight[0]][weight[1]];\n      setTimeout(() => {\n        document.getElementById(`${node.row}-${node.column}`).className =\n          'node weight';\n      }, 20 * i);\n    }\n  };\n\n\n  // Animates recursive divison maze with walls\n  const recursiveDivisionMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n\n        setDisable(true);\n\n        const walls = recursiveDivision(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n  // Animates random maze with walls\n  const buildRandomMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const walls = randomMaze(grid, start, target);\n\n        animateMaze(grid, walls);\n      }, 20);\n    }\n  };\n\n\n  // Animates random maze with weights\n  const buildRandomWeightMaze = () => {\n    if (!disable) {\n      removePattern(grid);\n      resetGrid(grid);\n      setTimeout(() => {\n        setDisable(true);\n        const start =\n          grid[currentStartCoordinates[0]][currentStartCoordinates[1]];\n        const target =\n          grid[currentTargetCoordinates[0]][currentTargetCoordinates[1]];\n        setDisable(true);\n        const weights = randomMaze(grid, start, target);\n\n        animateWeightMaze(grid, weights);\n      }, 20);\n    }\n  };\n\n  return (\n    <Fragment>\n      <Menu\n        resetAll={() => resetAll()}\n        startVisualize={() => startVisualize()}\n        disable={disable}\n        setDisable={setDisable}\n        algorithm={algorithm}\n        setAlgorithm={e => setAlgorithm(e)}\n        algorithmSpeed={algorithmSpeed}\n        setAlgorithmSpeed={e => setAlgorithmSpeed(e)}\n        speedValue={speedValue}\n        setSpeedValue={e => setSpeedValue(e)}\n        clearWalls={() => clearWalls(grid)}\n        recursiveDivisionMaze={() => recursiveDivisionMaze()}\n        buildRandomMaze={() => buildRandomMaze()}\n        buildRandomWeightMaze={() => buildRandomWeightMaze()}\n        showTutorial={showTutorial}\n        setShowTutorial={e => setShowTutorial(e)}\n      />\n\n      <Tutorial\n        showTutorial={showTutorial}\n        setShowTutorial={() => setShowTutorial()}\n      />\n      <div className='container'>\n        <table className={styles.grid}>\n          <tbody>\n            {grid.map((row, rowIdx) => {\n              return (\n                <tr key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, column, status, isVisited, shortest } = node;\n\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        shortest={shortest}\n                        row={row}\n                        column={column}\n                        status={status}\n                        isVisited={isVisited}\n                        isStartNodePressed={isStartNodePressed}\n                        isTargetNodePressed={isTargetNodePressed}\n                        pressedNode={pressedNode}\n                        onMouseDown={(row, column) =>\n                          handleMouseDown(row, column)\n                        }\n                        onMouseEnter={(row, column) =>\n                          handleMouseEnter(row, column)\n                        }\n                        onMouseUp={(row, column) => handleMouseUp(row, column)}\n                      ></Node>\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n      <Info algorithm={algorithm} setAlgorithm={setAlgorithm} />\n    </Fragment>\n  );\n};\n\n\n// Funtion used  to check if \"W\"-key is pressed. Used to build weights (can be used for other keys as well, not just \"W\"-key)\nfunction useKeyPress(targetKey) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  // If pressed key is our target key then set to true\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  // If released key is our target key then set to false\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n\nexport default Board;\n","/Users/ion/Desktop/React/pathfinder/src/components/Info.jsx",[],"/Users/ion/Desktop/React/pathfinder/src/components/Menu.jsx",["58","59"],"import React, { useState, useRef, useEffect, useCallback } from 'react';\n\nimport '../assets/styles/Menu.css';\n\nconst Menu = ({\n  algorithm,\n  setAlgorithm,\n  disable,\n  setDisable,\n  startVisualize,\n  algorithmSpeed,\n  setAlgorithmSpeed,\n  speedValue,\n  setSpeedValue,\n  clearWalls,\n  resetAll,\n  recursiveDivisionMaze,\n  buildRandomMaze,\n  buildRandomWeightMaze,\n  showTutorial,\n  setShowTutorial,\n}) => {\n  const [showAlgos, setShowAlgos] = useState(false);\n  const [showMazes, setShowMazes] = useState(false);\n  const [showSpeedMenu, setShowSpeedMenu] = useState(false);\n  const algoDropdown = useRef(null);\n  const mazeDropdown = useRef(null);\n  const speedDropdown = useRef(null);\n\n  const toggleAlgoDropdown = () => {\n    setShowAlgos(!showAlgos);\n    setShowMazes(false);\n    setShowSpeedMenu(false);\n  };\n\n  const toggleMazeDropdown = () => {\n    setShowMazes(!showMazes);\n    setShowAlgos(false);\n    setShowSpeedMenu(false);\n  };\n\n  const toggleSpeedDropdown = () => {\n    setShowSpeedMenu(!showSpeedMenu);\n    setShowMazes(false);\n    setShowAlgos(false);\n  };\n  const toggleTutorial = e => {\n    setShowTutorial(!showTutorial);\n  };\n  const closeDropdowns = useCallback(\n    e => {\n      if (!algoDropdown.current.contains(e.target)) {\n        setShowAlgos(false);\n      }\n      if (!mazeDropdown.current.contains(e.target)) {\n        setShowMazes(false);\n      }\n      if (!speedDropdown.current.contains(e.target)) {\n        setShowSpeedMenu(false);\n      }\n    },\n    [algoDropdown.current, mazeDropdown.current, speedDropdown.current]\n  );\n\n  useEffect(() => {\n    document.addEventListener('click', closeDropdowns);\n\n    return () => {\n      document.removeEventListener('click', closeDropdowns);\n    };\n  }, []);\n\n  const changeAlgorithm = e => {\n    if (e.target.innerText === \"Dijkstra's Algorithm\") {\n      setAlgorithm('dijkstra');\n    } else if (e.target.innerText === 'A* Search') {\n      setAlgorithm('astar');\n    } else if (e.target.innerText === 'Depth-first Search') {\n      setAlgorithm('dfs');\n    }\n  };\n\n  const setSpeed = e => {\n    if (e.target.innerText === 'Normal') {\n      setAlgorithmSpeed('Normal');\n      setSpeedValue(25);\n    } else if (e.target.innerText === 'Fast (default)') {\n      setAlgorithmSpeed('Fast');\n      setSpeedValue(10);\n    } else if (e.target.innerText === 'Slow') {\n      setAlgorithmSpeed('Slow');\n      setSpeedValue(100);\n    } else if (e.target.innerText === 'Ultra Slow') {\n      setAlgorithmSpeed('Ultra Slow');\n      setSpeedValue(500);\n    }\n  };\n\n  return (\n    <div className='menu'>\n      <h1>The Pathfinder</h1>\n      <nav>\n        <ul className='menu-list'>\n          <li ref={algoDropdown} onClick={() => toggleAlgoDropdown()}>\n            Algorithms\n            <span className='dropdown-arrow'></span>\n            <ul className={showAlgos === true ? 'algo-dropdown' : 'hidden'}>\n              <li onClick={e => changeAlgorithm(e)}>Dijkstra's Algorithm</li>\n              <li onClick={e => changeAlgorithm(e)}>A* Search</li>\n              <li onClick={e => changeAlgorithm(e)}>Depth-first Search</li>\n            </ul>\n          </li>\n\n          <li ref={mazeDropdown} onClick={() => toggleMazeDropdown()}>\n            Build Maze<span className='dropdown-arrow'></span>\n            <ul className={showMazes === true ? 'maze-dropdown' : 'hidden'}>\n              <li onClick={() => recursiveDivisionMaze()}>\n                Recursive Division\n              </li>\n              <li onClick={() => buildRandomMaze()}>Random maze pattern</li>\n              <li onClick={() => buildRandomWeightMaze()}>\n                Random Weight Maze\n              </li>\n            </ul>\n          </li>\n          <li ref={speedDropdown} onClick={() => toggleSpeedDropdown()}>\n            Speed: {algorithmSpeed}\n            <span className='dropdown-arrow'></span>\n            <ul\n              className={showSpeedMenu === true ? 'speed-dropdown' : 'hidden'}\n            >\n              <li onClick={e => setSpeed(e)}>Ultra Slow</li>\n\n              <li onClick={e => setSpeed(e)}>Slow</li>\n              <li onClick={e => setSpeed(e)}>Normal</li>\n              <li onClick={e => setSpeed(e)}>Fast (default)</li>\n            </ul>\n          </li>\n          <li>\n            <button\n              onClick={() => startVisualize()}\n              className={disable ? 'disabled' : ''}\n            >\n              Start{' '}\n              {algorithm === 'dijkstra'\n                ? \"Dijkstra's\"\n                : algorithm === 'astar'\n                ? 'A*'\n                : algorithm === 'dfs'\n                ? 'DFS'\n                : ''}\n            </button>\n          </li>\n          <li onClick={() => clearWalls()}>Clear walls</li>\n          <li onClick={() => resetAll()}>Reset board</li>\n\n          <li onClick={e => toggleTutorial(e)}>Tutorial</li>\n        </ul>\n      </nav>\n    </div>\n  );\n};\n\nexport default Menu;\n","/Users/ion/Desktop/React/pathfinder/src/algorithms/depthfirstsearch.js",[],"/Users/ion/Desktop/React/pathfinder/src/App.js",[],"/Users/ion/Desktop/React/pathfinder/src/components/Node.jsx",["60"],"import React from 'react';\n\nimport styles from '../assets/styles/Node.css';\n\nconst Node = props => {\n  const {\n    row,\n    column,\n    status,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    shortest,\n  } = props;\n\n  const typeOfNode =\n    status === 'start'\n      ? 'start'\n      : status === 'target'\n      ? 'target'\n      : status === 'wall'\n      ? 'wall'\n      : '';\n\n  const shortestClass = shortest ? 'node-shortest-path' : '';\n\n  return (\n    <td\n      onMouseDown={() => onMouseDown(row, column)}\n      onMouseEnter={() => onMouseEnter(row, column)}\n      onMouseUp={() => onMouseUp(row, column)}\n      className={`node ${typeOfNode} ${shortestClass}`}\n      id={`${row}-${column}`}\n    ></td>\n  );\n};\n\nexport default Node;\n","/Users/ion/Desktop/React/pathfinder/src/algorithms/dijkstra.js",[],"/Users/ion/Desktop/React/pathfinder/src/algorithms/randomMaze.js",[],"/Users/ion/Desktop/React/pathfinder/src/algorithms/astar.js",[],"/Users/ion/Desktop/React/pathfinder/src/algorithms/recursiveDivison.js",[],"/Users/ion/Desktop/React/pathfinder/src/components/Tutorial.jsx",[],{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","severity":1,"message":"66","line":130,"column":10,"nodeType":"67","messageId":"68","endLine":130,"endColumn":24},{"ruleId":"69","severity":1,"message":"70","line":932,"column":6,"nodeType":"71","endLine":932,"endColumn":8,"suggestions":"72"},{"ruleId":"69","severity":1,"message":"73","line":62,"column":5,"nodeType":"71","endLine":62,"endColumn":72,"suggestions":"74"},{"ruleId":"69","severity":1,"message":"75","line":71,"column":6,"nodeType":"71","endLine":71,"endColumn":8,"suggestions":"76"},{"ruleId":"65","severity":1,"message":"77","line":3,"column":8,"nodeType":"67","messageId":"68","endLine":3,"endColumn":14},"no-native-reassign",["78"],"no-negated-in-lhs",["79"],"no-unused-vars","'isOnWeightNode' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'downHandler' and 'upHandler'. Either include them or remove the dependency array.","ArrayExpression",["80"],"React Hook useCallback has unnecessary dependencies: 'algoDropdown.current', 'mazeDropdown.current', and 'speedDropdown.current'. Either exclude them or remove the dependency array. Mutable values like 'algoDropdown.current' aren't valid dependencies because mutating them doesn't re-render the component.",["81"],"React Hook useEffect has a missing dependency: 'closeDropdowns'. Either include it or remove the dependency array.",["82"],"'styles' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"83","fix":"84"},{"desc":"85","fix":"86"},{"desc":"87","fix":"88"},"Update the dependencies array to be: [downHandler, upHandler]",{"range":"89","text":"90"},"Update the dependencies array to be: []",{"range":"91","text":"92"},"Update the dependencies array to be: [closeDropdowns]",{"range":"93","text":"94"},[29090,29092],"[downHandler, upHandler]",[1483,1550],"[]",[1726,1728],"[closeDropdowns]"]